//"Build a Character" tool. Done by Ilya Mozzhukhin.
//Script builds a 2D character from bunch of local textures.
//Choosing a folder with a textures you should have an _Out.txt file generated by Photoshop script.

global proc string[] parseFile (string $filePath) {

global string $char_index;

//print $char_index;

// Open File
$fileId = `fopen $filePath "r"` ;

// Define String Array
string $dataArray[] ;

global int $scount = 0;

// Get The First Line
string $nextLine = `fgetline $fileId` ;

global float $docW;
global float $docH;

// Loop Until The String Size Is Zero (No Data On That Line)
while (size($nextLine) > 0)
{
   // Strip Whitespace From The Beginning And End Of The Line
   string $cleanLine = strip($nextLine) ;
   // Check if line is correct and add it to array
   string $chbuffer[];
   tokenize $cleanLine "," $chbuffer;

   if(($chbuffer[0]!="document_size")&&($chbuffer[0]!="LayerSet"))
   {
       $dataArray[size($dataArray)] = $cleanLine ;
       ++$scount;
   }

   if($chbuffer[0]=="document_size")
   {

       $docW = $chbuffer[1];
       $docH = $chbuffer[2];

     //  print ($curDocW+"\n"+"\n"+"\n"+"\n"+"\n");
       //print ($curDocW+"__"+$curDocH);
       //$dataArray[size($dataArray)] = $cleanLine ;
     //  ++$scount;
   }


   // Get Next Line And Continue
   $nextLine = `fgetline $fileId` ;
}

global string $data_names[];
global matrix $data_matrix[150][5];
string $buffer[];
for($j=0; $j<$scount; ++$j)
{
    tokenize $dataArray[$j] "," $buffer;
    $data_names[$j] = $buffer[0];
    for($jj=0; $jj<5; ++$jj)
    {
        $data_matrix[$j][$jj] = $buffer[$jj+1];
    }
}

return $dataArray;
}

global proc buildChar (string $char_names[], matrix $char_settings, int $pcount, string $dirpath, float $curDocW, float $curDocH)
{
    global string $char_index;
    string $curPolyName;
    float $curPolyW;
    float $curPolyH;
    float $scale = 0.01;
    for ($i=0; $i<$pcount; ++$i)
    {
        $curPolyName = $char_names[$i];
        $curPolyW = $scale*($char_settings[$i][2]-$char_settings[$i][0]);
        $curPolyH = $scale*($char_settings[$i][3]-$char_settings[$i][1]);
        polyPlane -n ($curPolyName+"_geo") -w $curPolyW -h $curPolyH -sw 1 -sh 1 -cuv 1 -ax 0 0 1 ;
        //setting the depth with the step of 10
        setAttr ($curPolyName+"_geo.translateZ") (-0.1*$i);
        setAttr ($curPolyName+"_geo.translateX") ($scale*($char_settings[$i][0]) + ($curPolyW/2) - ($scale*$curDocW/2));
        setAttr ($curPolyName+"_geo.translateY") (-($scale*($char_settings[$i][1]) + ($curPolyH/2) - ($scale*$curDocH/2)));
       // print ($curDocW+"\n"+"\n"+"\n"+"\n"+"\n");
        //create the shaders and textures
        shadingNode -asShader lambert -n ($curPolyName+"_mat");
        shadingNode -asTexture -isColorManaged file -n ($curPolyName+"_txtr");
        setAttr -type "string" ($curPolyName+"_txtr.fileTextureName") ($dirpath+"/"+$char_names[$i]+".png");
        connectAttr -force ($curPolyName+"_txtr.outColor") ($curPolyName+"_mat.color");
        connectAttr -force ($curPolyName+"_txtr.outTransparency") ($curPolyName+"_mat.transparency");
        select ($curPolyName+"_geo");
        hyperShade -assign ($curPolyName+"_mat");
        select -cl  ;
    }
}


global proc readPath (string $dirpath, string $type)
       {
		   global string $dirPath;
		   $dirPath = $dirpath;
		   parseFile ($dirpath+"/_Out.txt");
		}

fileBrowser ("readPath", "myText", "", 4);

buildChar ($data_names, $data_matrix, $scount, $dirPath, $docW, $docH);
